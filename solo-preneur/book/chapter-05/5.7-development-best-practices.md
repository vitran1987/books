## 5.7 Thực Hành Phát Triển Tốt Nhất: Quy Chuẩn và Kỷ Luật Code

### Technical debt đến đòi nợ: Khi code xấu trả giá đắt

Mentor Tuấn mở repository của Bạn Giỏi lên và scroll qua ba mươi files code mà Minh Anh đã viết trong hai tháng qua. Sau năm phút im lặng nhìn vào màn hình, anh đưa ra một nhận xét khiến cô hơi sốc: "Code của em chạy được và features hoạt động tốt - điều đó rất tốt cho giai đoạn đầu. Nhưng em đang tích lũy technical debt rất nhanh. Nếu không refactor sớm, sáu tháng nữa khi cần thêm features mới hoặc fix bugs, em sẽ mất gấp ba lần thời gian so với bây giờ vì code quá messy." Minh Anh có chút bối rối vì cô nghĩ code của mình ổn - tất cả tests đều pass, app chạy nhanh, users hài lòng. Nhưng Tuấn chỉ cho cô xem những vấn đề mà một developer kỳ cựu nhìn ra ngay: functions dài hai trăm dòng làm quá nhiều thứ khác nhau, variable names không rõ nghĩa như `data`, `temp`, `x`, code comments bằng tiếng Anh lẫn tiếng Việt không consistent, một số files không có comments gì cả, duplicate code xuất hiện ở năm chỗ khác nhau, không có error handling cho nhiều edge cases.

Anh giải thích khái niệm technical debt: giống như khoản nợ tài chính, khi cô viết code nhanh mà không follow best practices để ship features sớm, cô đang "vay nợ" thời gian của tương lai. Mỗi lần cô skip việc refactor một function phức tạp, skip việc viết documentation, skip việc extract duplicate code thành reusable components - cô đang thêm một khoản nợ nhỏ. Ban đầu những khoản nợ này không ảnh hưởng gì, nhưng chúng tích lũy theo thời gian và sinh ra "lãi suất" - mỗi lần cô cần modify code, thời gian required tăng lên vì code khó đọc, khó hiểu, khó test. Đến một lúc nào đó, "lãi suất" này lớn đến mức cô không thể thêm features mới nữa vì mọi thay đổi đều break existing code ở chỗ không ngờ tới. Lúc đó cô buộc phải "trả nợ" bằng cách rewrite lại toàn bộ - một công việc mất hàng tháng. Tuấn khuyên cô nên establish code quality standards ngay từ bây giờ và enforce chúng automatically, tránh tích lũy thêm debt.

### ESLint và Prettier: Cảnh sát code tự động

Bước đầu tiên Minh Anh làm là setup linting và formatting tools để enforce code style consistency. Cô install ESLint - một tool phân tích JavaScript/TypeScript code để tìm ra problematic patterns như unused variables, missing error handling, potential bugs. ESLint đi kèm với hàng trăm rules có thể enable, nhưng thay vì manually config từng rule, cô sử dụng một preset phổ biến là `eslint-config-airbnb` - bộ rules được Airbnb engineering team tổng hợp từ kinh nghiệm build production apps. Preset này enforce nhiều best practices như: functions không được dài hơn năm mươi dòng, variables phải có meaningful names ít nhất ba ký tự, phải có space sau commas, phải dùng const thay vì let khi variable không reassign, phải handle promise rejections.

Nhưng việc chỉ install ESLint không đủ - cô cần đảm bảo rules được check automatically mỗi khi code thay đổi. Minh Anh setup ESLint chạy trong ba contexts khác nhau. Thứ nhất, integrate vào VS Code editor để highlight errors ngay khi đang gõ code - nếu cô viết một function dài hơn năm mươi dòng, editor sẽ underline đỏ với message "Function is too long (52 lines). Maximum allowed is 50 lines." Thứ hai, add pre-commit hook với Husky - một tool chạy scripts automatically trước khi git commit. Mỗi khi Minh Anh chạy `git commit`, Husky trigger ESLint check tất cả staged files, và nếu có linting errors, commit bị block cho đến khi cô fix xong. Điều này đảm bảo code xấu không bao giờ được commit vào repository. Thứ ba, integrate vào GitHub Actions CI pipeline - ngay cả khi pre-commit hook somehow bị bypass, CI sẽ chạy linter và reject pull request nếu code vi phạm rules.

Cùng với ESLint, cô setup Prettier - một opinionated code formatter tự động format code theo một style chuẩn. Khác với ESLint focus vào code quality, Prettier focus vào code aesthetics: indentation, line length, quotes, trailing commas. Điều kỳ diệu của Prettier là nó không có options để customize - mọi project sử dụng Prettier đều có cùng một style, tránh bikeshedding arguments về nên dùng single quotes hay double quotes. Minh Anh config Prettier chạy automatically mỗi khi save file trong VS Code và cũng trong pre-commit hook. Kết quả là mỗi khi cô lưu file, code tự động reformat đẹp mắt - một function messy với indentation sai, line length quá dài, spaces không đều sẽ trở thành code sạch sẽ, consistent trong một giây.

Việc enforce linting và formatting rules đã cải thiện code quality ngay lập tức. Trong tuần đầu tiên, ESLint phát hiện bốn mươi hai potential bugs mà Minh Anh không nhận ra: năm biến được khai báo nhưng không bao giờ sử dụng (dead code), mười hai promises không có error handling (app sẽ crash nếu promise reject), tám functions có complexity quá cao (quá nhiều if/else nested), mười bảy chỗ sử dụng == thay vì === (có thể gây type coercion bugs). Sau khi fix tất cả warnings, cô chạy lại test suite và phát hiện ba bugs thực sự mà tests trước đây không catch được - tất cả đều liên quan đến error handling thiếu.

### Git workflow: Branching strategy và code reviews

Trước đây, Minh Anh code tất cả trực tiếp trên nhánh `main` và commit bất cứ khi nào cô muốn. Điều này tạo ra nhiều vấn đề: commits không có structure rõ ràng (một commit chứa lẫn lộn ba features khác nhau), commit messages không descriptive ("fix bug", "update code"), và đôi khi cô push code broken lên `main` làm production deploy fail. Tuấn hướng dẫn cô establish một Git branching strategy proper.

Cô áp dụng Git Flow - một branching model phổ biến. Nhánh `main` luôn luôn chứa production-ready code và protected - không ai có thể push trực tiếp lên `main`, mọi changes phải qua pull requests. Nhánh `develop` là nơi integrate các features đang được phát triển. Mỗi feature mới được code trên một branch riêng biệt với naming convention `feature/ten-feature` - ví dụ `feature/group-chat`, `feature/payment-integration`. Khi feature hoàn thành, Minh Anh tạo pull request từ feature branch vào `develop`. Sau khi merge vào `develop` và test kỹ, cô tạo một release branch `release/v1.2.0`, run final tests, rồi merge vào `main` để deploy production.

Điều quan trọng nhất Tuấn dạy cô là không bao giờ commit code mà mình không review lại ít nhất một lần. Mỗi khi Minh Anh hoàn thành một feature và sắp tạo pull request, cô mở GitHub web interface, xem tab "Files changed" để review tất cả code changes như thể cô đang review code của người khác. Process này giúp cô catch nhiều lỗi nhỏ: quên xóa console.log debug statements, để lại commented-out code, có typo trong comments, forgot to remove unused imports. Việc review code của chính mình với fresh eyes - đặc biệt sau khi休息 vài giờ - rất hiệu quả trong việc phát hiện bugs và improve code quality.

Nhưng self-review có giới hạn - đôi khi cô quá quen với cách tiếp cận của bản thân mà không nhận ra có approach tốt hơn. Giải pháp là AI code reviewer. Minh Anh sử dụng GitHub Copilot Chat với một custom prompt: "Hãy review pull request này như một senior developer. Tìm kiếm: 1) Potential bugs và edge cases không được handle, 2) Performance issues, 3) Security vulnerabilities, 4) Code smells và refactoring opportunities, 5) Missing error handling, 6) Inconsistent naming hoặc style." Copilot analyze toàn bộ diff và trả về một detailed review với specific line comments. Ví dụ với một pull request implement group chat feature, Copilot chỉ ra năm issues: function `sendMessage` không validate message length (users có thể spam messages dài vạn ký tự), database query trong loop gây N+1 problem (nên dùng JOIN), WebSocket connection không có timeout (có thể memory leak), error khi send message fail không được show cho user, và function naming `doStuff` quá generic nên rename thành `broadcastMessageToGroup`.

### Documentation: Code tự giải thích và comments có ý nghĩa

Một ngày Minh Anh quay lại xem code cô đã viết ba tuần trước để implement một AI prompt optimization algorithm. Cô nhìn vào một function dài bảy mươi dòng với tên `optimizePrompt` và hoàn toàn không nhớ logic bên trong làm gì. Có ba nested loops, năm if statements, và hai mươi variables với tên như `temp`, `result`, `data2`, `x`. Cô phải mất bốn mươi phút đọc từng dòng code để hiểu lại algorithm - một function mà chính cô viết ra. Lúc đó cô nhận ra tầm quan trọng của documentation và self-documenting code.

Tuấn dạy cô hai principles về documentation. Thứ nhất, code tốt nên tự giải thích được mà không cần comments - đạt được bằng cách sử dụng meaningful names và small functions. Thay vì viết comment giải thích một đoạn code phức tạp làm gì, nên extract đoạn đó ra một function với tên descriptive. Ví dụ thay vì comment "// Lọc các students có điểm trung bình trên 8 và đã hoàn thành ít nhất 10 bài tập", cô nên tạo function `getHighPerformingStudents(students)` với implementation bên trong. Khi đọc code, người ta sẽ hiểu ngay ý nghĩa mà không cần đọc implementation details.

Thứ hai, khi cần comments, hãy explain "why" chứ không phải "what". Code đã cho biết "what" rồi - nếu cô viết `students.filter(s => s.averageScore > 8)`, rõ ràng đây là filtering students với điểm trên 8, không cần comment "// Filter students with score > 8." Nhưng comment nên explain tại sao cutoff là 8 chứ không phải 7 hay 9: "// Chỉ show students có performance cao (>8) trong leaderboard để tạo động lực cạnh tranh, dựa theo feedback từ beta testing." Comment này giải thích business logic và context mà không thể infer từ code.

Minh Anh refactor function `optimizePrompt` theo principles này. Trước đây, function một khối bảy mươi dòng với logic lẫn lộn. Sau refactor, function chính chỉ có mười dòng call các sub-functions: `extractKeywords()`, `rankByRelevance()`, `limitToTokenBudget()`, `formatForGPT()`. Mỗi sub-function có tên rõ ràng và làm một việc duy nhất. Variables được rename: `temp` thành `filteredKeywords`, `data2` thành `rankedPromptSegments`, `x` thành `tokenCount`. Kết quả là function mới dễ đọc đến mức người không biết gì về prompt engineering cũng hiểu được high-level flow. Implementation details ẩn bên trong các sub-functions, chỉ cần đọc khi muốn hiểu sâu hơn.

Cô còn viết API documentation bằng JSDoc comments cho tất cả public functions và classes. JSDoc cho phép cô annotate types, parameters, return values, và examples ngay trong code comments, sau đó generate ra HTML documentation website automatically. Ví dụ function `gradeHomework(imageUrl: string, gradeLevel: number)` có JSDoc comment giải thích: "Chấm điểm bài tập toán học từ ảnh chụp. Sử dụng OCR để nhận dạng chữ viết, GPT-5.1 để phân tích đúng/sai, và Gemini 3 Pro để sinh feedback tiếng Việt." Comment còn include parameter descriptions, return value format, và một code example cách gọi function này. Khi hover chuột lên function name trong VS Code, editor hiển thị full JSDoc tooltip - rất hữu ích khi cô quay lại code sau vài tuần.

### Security best practices: OWASP Top 10 và bảo mật dữ liệu

Bảo mật là một aspect mà Minh Anh ban đầu không chú ý nhiều - cô nghĩ app EdTech cho học sinh không có thông tin nhạy cảm lắm nên không cần security cao như banking apps. Nhưng Tuấn chỉ ra rằng app của cô đang lưu trữ dữ liệu cá nhân của học sinh (họ tên, email, số điện thoại, ảnh bài tập), payment information của phụ huynh, và intellectual property (nội dung giáo dục do AI sinh ra). Nếu bị hack, không chỉ mất data mà còn mất trust của users và có thể vi phạm luật bảo vệ dữ liệu cá nhân của Việt Nam. Anh recommend cô follow OWASP Top 10 - danh sách mười vulnerabilities phổ biến nhất trong web applications và cách phòng tránh.

Vulnerability số một là Injection attacks, đặc biệt SQL injection. Minh Anh đang dùng Prisma ORM nên đã được protect tự động - Prisma escape tất cả user inputs trước khi construct SQL queries. Nhưng cô vẫn audit code để đảm bảo không có chỗ nào construct raw SQL queries từ user input. Vulnerability số hai là Broken Authentication - cô ensure rằng passwords được hash với bcrypt (không store plaintext), JWT tokens có expiration time và được verify đúng cách, và implement rate limiting để prevent brute-force attacks. Cô thêm một middleware check số lần login fail - nếu một IP address fail login năm lần trong mười phút, block IP đó trong ba mươi phút.

Vulnerability số ba là Sensitive Data Exposure. Minh Anh review tất cả API endpoints để ensure không expose sensitive data không cần thiết. Ví dụ endpoint GET `/api/students/:id` trước đây return toàn bộ student object including password hash và email - thông tin không cần thiết cho frontend. Cô refactor để chỉ return những fields frontend thực sự cần: id, name, avatar, grade level, learning progress. Password hashes và emails chỉ return ở endpoint `/api/profile` khi user request chính profile của mình, và chỉ sau khi verify JWT token.

Security audit còn phát hiện một issue nghiêm trọng: ảnh bài tập của học sinh được lưu trên AWS S3 với public read access - nghĩa là bất kỳ ai có URL của ảnh đều xem được. Điều này vi phạm privacy vì bài tập có thể chứa thông tin cá nhân hoặc ảnh chân dung học sinh. Minh Anh fix bằng cách chuyển S3 bucket sang private mode và implement signed URLs - mỗi khi frontend cần display một ảnh, backend generate một temporary URL có hiệu lực trong mười lăm phút, chỉ người có URL này mới access được ảnh. Sau mười lăm phút URL expire và không thể sử dụng nữa.

Cô còn implement Content Security Policy (CSP) headers để prevent XSS attacks - browser chỉ được phép load scripts từ trusted domains, không execute inline scripts, và không load resources từ unknown sources. Setup HTTPS everywhere với SSL certificates từ Let's Encrypt và enforce HSTS (HTTP Strict Transport Security) để ensure mọi connections đều encrypted. Enable CORS (Cross-Origin Resource Sharing) nhưng chỉ allow requests từ chính domain của app, block mọi cross-origin requests từ external websites để prevent CSRF attacks.

### Cost monitoring và optimization strategies

Ngoài infrastructure costs mà cô đã optimize trong chapter trước, Minh Anh còn cần monitor development costs - thời gian và resources bỏ ra để build features mới, fix bugs, maintain code. Cô track metrics như: average time to implement một feature request (hiện tại bốn ngày), average time to fix một bug (hai giờ), percentage of time spent on new features vs maintenance (sáu mươi/bốn mươi), và code churn rate (percentage of code được rewrite sau ít hơn ba tháng - indicator của technical debt).

Để optimize development costs, cô establish một số practices. Thứ nhất, before implementing bất kỳ feature request nào, cô dành ba mươi phút để design và estimate effort. Quá nhiều lần cô bắt tay vào code một feature mà nghĩ sẽ mất một ngày, rồi realize sau hai ngày rằng feature phức tạp hơn nhiều so với tưởng tượng vì có nhiều edge cases. Giờ cô gõ feature description vào GitHub Copilot Chat và hỏi: "Hãy list tất cả technical challenges và edge cases cần xử lý để implement feature này. Estimate effort." AI analysis giúp cô predict effort chính xác hơn và quyết định có nên implement ngay hay defer cho later.

Thứ hai, cô prioritize ruthlessly theo impact/effort ratio. Mỗi feature request được score từ một đến mười về hai dimensions: user impact (feature này quan trọng thế nào với users) và implementation effort (mất bao nhiêu thời gian code). Features với high impact và low effort được làm trước (ví dụ: add keyboard shortcuts, improve error messages). Features với low impact high effort bị defer hoặc reject (ví dụ: hỗ trợ dark mode, tạo mobile app native). Approach này giúp cô maximize value delivered per unit of time invested.

Thứ ba, cô reuse code aggressively. Mỗi khi implement một feature, cô suy nghĩ liệu logic này có thể được generalize thành một reusable component hoặc utility function không. Ví dụ khi implement image upload cho homework submissions, cô tạo một generic `ImageUploader` component có thể reuse cho profile avatars, course thumbnails, và bất kỳ chỗ nào cần upload images. Khi cần thêm image upload ở một feature mới, thay vì viết lại từ đầu (mất hai giờ), cô chỉ cần import và sử dụng component này (mất năm phút). Repository của cô giờ có một thư mục `shared/` chứa ba mươi reusable components và utilities - mỗi component save vài giờ development time khi được reused.

### Kết quả: Code quality dẫn đến velocity cao hơn

Ba tháng sau khi establish toàn bộ development best practices, Minh Anh ngồi review metrics và thấy những cải thiện dramatic. Code quality metrics từ SonarQube (một tool analyze code quality) cho thấy technical debt ratio giảm từ hai mươi lăm phần trăm xuống tám phần trăm, code duplication giảm từ mười hai phần trăm xuống ba phần trăm, test coverage tăng từ sáu mươi phần trăm lên tám mươi lăm phần trăm. Nhưng quan trọng hơn là impact lên development velocity và product quality.

Average time to implement một feature request giảm từ bốn ngày xuống hai ngày - không phải vì cô code nhanh hơn, mà vì code clean hơn, dễ modify hơn, và có nhiều reusable components. Average time to fix một bug giảm từ hai giờ xuống ba mươi phút vì linting và testing đã prevent phần lớn bugs reach production, và những bugs còn lại dễ debug hơn nhờ code structured tốt. Percentage of time spent on maintenance giảm từ bốn mươi phần trăm xuống hai mươi phần trăm, nghĩa là cô có nhiều thời gian hơn để build features mới thay vì fix bugs và refactor code cũ.

Production incidents giảm từ năm incidents per month xuống không phẩy năm incidents per month. Security audit chạy hàng tháng không phát hiện vulnerability nào mới trong ba tháng liên tiếp. User-reported bugs giảm từ mười bugs per week xuống hai bugs per week, và cả hai đều là minor UI issues chứ không phải critical bugs. Code review time giảm từ hai giờ per pull request xuống hai mươi phút vì AI reviewer đã catch hầu hết issues trước.

Nhưng impact lớn nhất là psychological. Trước đây, mỗi khi cần thêm một feature mới hoặc modify existing code, Minh Anh cảm thấy lo lắng vì sợ break things ở chỗ khác. Cô phải rất careful khi modify code, mất nhiều thời gian manual testing, và vẫn không confident. Giờ với comprehensive test suite, linting, code review process, và clean code structure, cô confident modify bất kỳ phần nào của codebase. Tests sẽ catch bugs, linter sẽ prevent bad patterns, và code dễ hiểu nên dễ reason about correctness. Confidence này translate thành higher velocity và willingness to experiment với new approaches thay vì stick với safe but suboptimal solutions.

Minh Anh nhận ra rằng investing time vào code quality và development practices không phải là "overhead" làm chậm development - ngược lại, nó là foundation cho sustainable long-term velocity. Trong hai tháng đầu khi chưa có practices, cô ship features nhanh nhưng accumulate debt. Tháng thứ ba và thứ tư, velocity giảm vì phải deal với bugs và technical debt. Nhưng sau khi establish practices từ tháng thứ năm, velocity tăng trở lại và maintain stable ở mức cao - cô có thể sustain velocity này trong nhiều tháng tới mà không bị slowdown. Đây chính xác là điều mà "ship fast AND ship quality" philosophy mang lại: speed ở long term, không chỉ short-term bursts followed by slowdowns.

